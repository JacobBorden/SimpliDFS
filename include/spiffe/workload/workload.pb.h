// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spiffe/workload/workload.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_spiffe_2fworkload_2fworkload_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_spiffe_2fworkload_2fworkload_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_spiffe_2fworkload_2fworkload_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_spiffe_2fworkload_2fworkload_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_spiffe_2fworkload_2fworkload_2eproto;
class JWTBundlesRequest;
struct JWTBundlesRequestDefaultTypeInternal;
extern JWTBundlesRequestDefaultTypeInternal _JWTBundlesRequest_default_instance_;
class JWTBundlesResponse;
struct JWTBundlesResponseDefaultTypeInternal;
extern JWTBundlesResponseDefaultTypeInternal _JWTBundlesResponse_default_instance_;
class JWTBundlesResponse_BundlesEntry_DoNotUse;
struct JWTBundlesResponse_BundlesEntry_DoNotUseDefaultTypeInternal;
extern JWTBundlesResponse_BundlesEntry_DoNotUseDefaultTypeInternal _JWTBundlesResponse_BundlesEntry_DoNotUse_default_instance_;
class JWTSVID;
struct JWTSVIDDefaultTypeInternal;
extern JWTSVIDDefaultTypeInternal _JWTSVID_default_instance_;
class JWTSVIDRequest;
struct JWTSVIDRequestDefaultTypeInternal;
extern JWTSVIDRequestDefaultTypeInternal _JWTSVIDRequest_default_instance_;
class JWTSVIDResponse;
struct JWTSVIDResponseDefaultTypeInternal;
extern JWTSVIDResponseDefaultTypeInternal _JWTSVIDResponse_default_instance_;
class ValidateJWTSVIDRequest;
struct ValidateJWTSVIDRequestDefaultTypeInternal;
extern ValidateJWTSVIDRequestDefaultTypeInternal _ValidateJWTSVIDRequest_default_instance_;
class ValidateJWTSVIDResponse;
struct ValidateJWTSVIDResponseDefaultTypeInternal;
extern ValidateJWTSVIDResponseDefaultTypeInternal _ValidateJWTSVIDResponse_default_instance_;
class X509BundlesRequest;
struct X509BundlesRequestDefaultTypeInternal;
extern X509BundlesRequestDefaultTypeInternal _X509BundlesRequest_default_instance_;
class X509BundlesResponse;
struct X509BundlesResponseDefaultTypeInternal;
extern X509BundlesResponseDefaultTypeInternal _X509BundlesResponse_default_instance_;
class X509BundlesResponse_BundlesEntry_DoNotUse;
struct X509BundlesResponse_BundlesEntry_DoNotUseDefaultTypeInternal;
extern X509BundlesResponse_BundlesEntry_DoNotUseDefaultTypeInternal _X509BundlesResponse_BundlesEntry_DoNotUse_default_instance_;
class X509SVID;
struct X509SVIDDefaultTypeInternal;
extern X509SVIDDefaultTypeInternal _X509SVID_default_instance_;
class X509SVIDRequest;
struct X509SVIDRequestDefaultTypeInternal;
extern X509SVIDRequestDefaultTypeInternal _X509SVIDRequest_default_instance_;
class X509SVIDResponse;
struct X509SVIDResponseDefaultTypeInternal;
extern X509SVIDResponseDefaultTypeInternal _X509SVIDResponse_default_instance_;
class X509SVIDResponse_FederatedBundlesEntry_DoNotUse;
struct X509SVIDResponse_FederatedBundlesEntry_DoNotUseDefaultTypeInternal;
extern X509SVIDResponse_FederatedBundlesEntry_DoNotUseDefaultTypeInternal _X509SVIDResponse_FederatedBundlesEntry_DoNotUse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::JWTBundlesRequest* Arena::CreateMaybeMessage<::JWTBundlesRequest>(Arena*);
template<> ::JWTBundlesResponse* Arena::CreateMaybeMessage<::JWTBundlesResponse>(Arena*);
template<> ::JWTBundlesResponse_BundlesEntry_DoNotUse* Arena::CreateMaybeMessage<::JWTBundlesResponse_BundlesEntry_DoNotUse>(Arena*);
template<> ::JWTSVID* Arena::CreateMaybeMessage<::JWTSVID>(Arena*);
template<> ::JWTSVIDRequest* Arena::CreateMaybeMessage<::JWTSVIDRequest>(Arena*);
template<> ::JWTSVIDResponse* Arena::CreateMaybeMessage<::JWTSVIDResponse>(Arena*);
template<> ::ValidateJWTSVIDRequest* Arena::CreateMaybeMessage<::ValidateJWTSVIDRequest>(Arena*);
template<> ::ValidateJWTSVIDResponse* Arena::CreateMaybeMessage<::ValidateJWTSVIDResponse>(Arena*);
template<> ::X509BundlesRequest* Arena::CreateMaybeMessage<::X509BundlesRequest>(Arena*);
template<> ::X509BundlesResponse* Arena::CreateMaybeMessage<::X509BundlesResponse>(Arena*);
template<> ::X509BundlesResponse_BundlesEntry_DoNotUse* Arena::CreateMaybeMessage<::X509BundlesResponse_BundlesEntry_DoNotUse>(Arena*);
template<> ::X509SVID* Arena::CreateMaybeMessage<::X509SVID>(Arena*);
template<> ::X509SVIDRequest* Arena::CreateMaybeMessage<::X509SVIDRequest>(Arena*);
template<> ::X509SVIDResponse* Arena::CreateMaybeMessage<::X509SVIDResponse>(Arena*);
template<> ::X509SVIDResponse_FederatedBundlesEntry_DoNotUse* Arena::CreateMaybeMessage<::X509SVIDResponse_FederatedBundlesEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class X509SVIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:X509SVIDRequest) */ {
 public:
  inline X509SVIDRequest() : X509SVIDRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR X509SVIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  X509SVIDRequest(const X509SVIDRequest& from);
  X509SVIDRequest(X509SVIDRequest&& from) noexcept
    : X509SVIDRequest() {
    *this = ::std::move(from);
  }

  inline X509SVIDRequest& operator=(const X509SVIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline X509SVIDRequest& operator=(X509SVIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const X509SVIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const X509SVIDRequest* internal_default_instance() {
    return reinterpret_cast<const X509SVIDRequest*>(
               &_X509SVIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(X509SVIDRequest& a, X509SVIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(X509SVIDRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(X509SVIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  X509SVIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<X509SVIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const X509SVIDRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const X509SVIDRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "X509SVIDRequest";
  }
  protected:
  explicit X509SVIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:X509SVIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class X509SVIDResponse_FederatedBundlesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<X509SVIDResponse_FederatedBundlesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<X509SVIDResponse_FederatedBundlesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  X509SVIDResponse_FederatedBundlesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR X509SVIDResponse_FederatedBundlesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit X509SVIDResponse_FederatedBundlesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const X509SVIDResponse_FederatedBundlesEntry_DoNotUse& other);
  static const X509SVIDResponse_FederatedBundlesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const X509SVIDResponse_FederatedBundlesEntry_DoNotUse*>(&_X509SVIDResponse_FederatedBundlesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "X509SVIDResponse.FederatedBundlesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};

// -------------------------------------------------------------------

class X509SVIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:X509SVIDResponse) */ {
 public:
  inline X509SVIDResponse() : X509SVIDResponse(nullptr) {}
  ~X509SVIDResponse() override;
  explicit PROTOBUF_CONSTEXPR X509SVIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  X509SVIDResponse(const X509SVIDResponse& from);
  X509SVIDResponse(X509SVIDResponse&& from) noexcept
    : X509SVIDResponse() {
    *this = ::std::move(from);
  }

  inline X509SVIDResponse& operator=(const X509SVIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline X509SVIDResponse& operator=(X509SVIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const X509SVIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const X509SVIDResponse* internal_default_instance() {
    return reinterpret_cast<const X509SVIDResponse*>(
               &_X509SVIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(X509SVIDResponse& a, X509SVIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(X509SVIDResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(X509SVIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  X509SVIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<X509SVIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const X509SVIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const X509SVIDResponse& from) {
    X509SVIDResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(X509SVIDResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "X509SVIDResponse";
  }
  protected:
  explicit X509SVIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSvidsFieldNumber = 1,
    kCrlFieldNumber = 2,
    kFederatedBundlesFieldNumber = 3,
  };
  // repeated .X509SVID svids = 1;
  int svids_size() const;
  private:
  int _internal_svids_size() const;
  public:
  void clear_svids();
  ::X509SVID* mutable_svids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::X509SVID >*
      mutable_svids();
  private:
  const ::X509SVID& _internal_svids(int index) const;
  ::X509SVID* _internal_add_svids();
  public:
  const ::X509SVID& svids(int index) const;
  ::X509SVID* add_svids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::X509SVID >&
      svids() const;

  // repeated bytes crl = 2;
  int crl_size() const;
  private:
  int _internal_crl_size() const;
  public:
  void clear_crl();
  const std::string& crl(int index) const;
  std::string* mutable_crl(int index);
  void set_crl(int index, const std::string& value);
  void set_crl(int index, std::string&& value);
  void set_crl(int index, const char* value);
  void set_crl(int index, const void* value, size_t size);
  std::string* add_crl();
  void add_crl(const std::string& value);
  void add_crl(std::string&& value);
  void add_crl(const char* value);
  void add_crl(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& crl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_crl();
  private:
  const std::string& _internal_crl(int index) const;
  std::string* _internal_add_crl();
  public:

  // map<string, bytes> federated_bundles = 3;
  int federated_bundles_size() const;
  private:
  int _internal_federated_bundles_size() const;
  public:
  void clear_federated_bundles();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_federated_bundles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_federated_bundles();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      federated_bundles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_federated_bundles();

  // @@protoc_insertion_point(class_scope:X509SVIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::X509SVID > svids_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> crl_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        X509SVIDResponse_FederatedBundlesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> federated_bundles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class X509SVID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:X509SVID) */ {
 public:
  inline X509SVID() : X509SVID(nullptr) {}
  ~X509SVID() override;
  explicit PROTOBUF_CONSTEXPR X509SVID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  X509SVID(const X509SVID& from);
  X509SVID(X509SVID&& from) noexcept
    : X509SVID() {
    *this = ::std::move(from);
  }

  inline X509SVID& operator=(const X509SVID& from) {
    CopyFrom(from);
    return *this;
  }
  inline X509SVID& operator=(X509SVID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const X509SVID& default_instance() {
    return *internal_default_instance();
  }
  static inline const X509SVID* internal_default_instance() {
    return reinterpret_cast<const X509SVID*>(
               &_X509SVID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(X509SVID& a, X509SVID& b) {
    a.Swap(&b);
  }
  inline void Swap(X509SVID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(X509SVID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  X509SVID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<X509SVID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const X509SVID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const X509SVID& from) {
    X509SVID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(X509SVID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "X509SVID";
  }
  protected:
  explicit X509SVID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpiffeIdFieldNumber = 1,
    kX509SvidFieldNumber = 2,
    kX509SvidKeyFieldNumber = 3,
    kBundleFieldNumber = 4,
    kHintFieldNumber = 5,
  };
  // string spiffe_id = 1;
  void clear_spiffe_id();
  const std::string& spiffe_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spiffe_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spiffe_id();
  PROTOBUF_NODISCARD std::string* release_spiffe_id();
  void set_allocated_spiffe_id(std::string* spiffe_id);
  private:
  const std::string& _internal_spiffe_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spiffe_id(const std::string& value);
  std::string* _internal_mutable_spiffe_id();
  public:

  // bytes x509_svid = 2;
  void clear_x509_svid();
  const std::string& x509_svid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_x509_svid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_x509_svid();
  PROTOBUF_NODISCARD std::string* release_x509_svid();
  void set_allocated_x509_svid(std::string* x509_svid);
  private:
  const std::string& _internal_x509_svid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x509_svid(const std::string& value);
  std::string* _internal_mutable_x509_svid();
  public:

  // bytes x509_svid_key = 3;
  void clear_x509_svid_key();
  const std::string& x509_svid_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_x509_svid_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_x509_svid_key();
  PROTOBUF_NODISCARD std::string* release_x509_svid_key();
  void set_allocated_x509_svid_key(std::string* x509_svid_key);
  private:
  const std::string& _internal_x509_svid_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x509_svid_key(const std::string& value);
  std::string* _internal_mutable_x509_svid_key();
  public:

  // bytes bundle = 4;
  void clear_bundle();
  const std::string& bundle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bundle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bundle();
  PROTOBUF_NODISCARD std::string* release_bundle();
  void set_allocated_bundle(std::string* bundle);
  private:
  const std::string& _internal_bundle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bundle(const std::string& value);
  std::string* _internal_mutable_bundle();
  public:

  // string hint = 5;
  void clear_hint();
  const std::string& hint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hint();
  PROTOBUF_NODISCARD std::string* release_hint();
  void set_allocated_hint(std::string* hint);
  private:
  const std::string& _internal_hint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hint(const std::string& value);
  std::string* _internal_mutable_hint();
  public:

  // @@protoc_insertion_point(class_scope:X509SVID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spiffe_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x509_svid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x509_svid_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bundle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class X509BundlesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:X509BundlesRequest) */ {
 public:
  inline X509BundlesRequest() : X509BundlesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR X509BundlesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  X509BundlesRequest(const X509BundlesRequest& from);
  X509BundlesRequest(X509BundlesRequest&& from) noexcept
    : X509BundlesRequest() {
    *this = ::std::move(from);
  }

  inline X509BundlesRequest& operator=(const X509BundlesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline X509BundlesRequest& operator=(X509BundlesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const X509BundlesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const X509BundlesRequest* internal_default_instance() {
    return reinterpret_cast<const X509BundlesRequest*>(
               &_X509BundlesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(X509BundlesRequest& a, X509BundlesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(X509BundlesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(X509BundlesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  X509BundlesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<X509BundlesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const X509BundlesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const X509BundlesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "X509BundlesRequest";
  }
  protected:
  explicit X509BundlesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:X509BundlesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class X509BundlesResponse_BundlesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<X509BundlesResponse_BundlesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<X509BundlesResponse_BundlesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  X509BundlesResponse_BundlesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR X509BundlesResponse_BundlesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit X509BundlesResponse_BundlesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const X509BundlesResponse_BundlesEntry_DoNotUse& other);
  static const X509BundlesResponse_BundlesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const X509BundlesResponse_BundlesEntry_DoNotUse*>(&_X509BundlesResponse_BundlesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "X509BundlesResponse.BundlesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};

// -------------------------------------------------------------------

class X509BundlesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:X509BundlesResponse) */ {
 public:
  inline X509BundlesResponse() : X509BundlesResponse(nullptr) {}
  ~X509BundlesResponse() override;
  explicit PROTOBUF_CONSTEXPR X509BundlesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  X509BundlesResponse(const X509BundlesResponse& from);
  X509BundlesResponse(X509BundlesResponse&& from) noexcept
    : X509BundlesResponse() {
    *this = ::std::move(from);
  }

  inline X509BundlesResponse& operator=(const X509BundlesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline X509BundlesResponse& operator=(X509BundlesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const X509BundlesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const X509BundlesResponse* internal_default_instance() {
    return reinterpret_cast<const X509BundlesResponse*>(
               &_X509BundlesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(X509BundlesResponse& a, X509BundlesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(X509BundlesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(X509BundlesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  X509BundlesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<X509BundlesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const X509BundlesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const X509BundlesResponse& from) {
    X509BundlesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(X509BundlesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "X509BundlesResponse";
  }
  protected:
  explicit X509BundlesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kCrlFieldNumber = 1,
    kBundlesFieldNumber = 2,
  };
  // repeated bytes crl = 1;
  int crl_size() const;
  private:
  int _internal_crl_size() const;
  public:
  void clear_crl();
  const std::string& crl(int index) const;
  std::string* mutable_crl(int index);
  void set_crl(int index, const std::string& value);
  void set_crl(int index, std::string&& value);
  void set_crl(int index, const char* value);
  void set_crl(int index, const void* value, size_t size);
  std::string* add_crl();
  void add_crl(const std::string& value);
  void add_crl(std::string&& value);
  void add_crl(const char* value);
  void add_crl(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& crl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_crl();
  private:
  const std::string& _internal_crl(int index) const;
  std::string* _internal_add_crl();
  public:

  // map<string, bytes> bundles = 2;
  int bundles_size() const;
  private:
  int _internal_bundles_size() const;
  public:
  void clear_bundles();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_bundles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_bundles();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      bundles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_bundles();

  // @@protoc_insertion_point(class_scope:X509BundlesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> crl_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        X509BundlesResponse_BundlesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> bundles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class JWTSVIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JWTSVIDRequest) */ {
 public:
  inline JWTSVIDRequest() : JWTSVIDRequest(nullptr) {}
  ~JWTSVIDRequest() override;
  explicit PROTOBUF_CONSTEXPR JWTSVIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JWTSVIDRequest(const JWTSVIDRequest& from);
  JWTSVIDRequest(JWTSVIDRequest&& from) noexcept
    : JWTSVIDRequest() {
    *this = ::std::move(from);
  }

  inline JWTSVIDRequest& operator=(const JWTSVIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JWTSVIDRequest& operator=(JWTSVIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JWTSVIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JWTSVIDRequest* internal_default_instance() {
    return reinterpret_cast<const JWTSVIDRequest*>(
               &_JWTSVIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(JWTSVIDRequest& a, JWTSVIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JWTSVIDRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JWTSVIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JWTSVIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JWTSVIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JWTSVIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JWTSVIDRequest& from) {
    JWTSVIDRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JWTSVIDRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JWTSVIDRequest";
  }
  protected:
  explicit JWTSVIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudienceFieldNumber = 1,
    kSpiffeIdFieldNumber = 2,
  };
  // repeated string audience = 1;
  int audience_size() const;
  private:
  int _internal_audience_size() const;
  public:
  void clear_audience();
  const std::string& audience(int index) const;
  std::string* mutable_audience(int index);
  void set_audience(int index, const std::string& value);
  void set_audience(int index, std::string&& value);
  void set_audience(int index, const char* value);
  void set_audience(int index, const char* value, size_t size);
  std::string* add_audience();
  void add_audience(const std::string& value);
  void add_audience(std::string&& value);
  void add_audience(const char* value);
  void add_audience(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& audience() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_audience();
  private:
  const std::string& _internal_audience(int index) const;
  std::string* _internal_add_audience();
  public:

  // string spiffe_id = 2;
  void clear_spiffe_id();
  const std::string& spiffe_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spiffe_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spiffe_id();
  PROTOBUF_NODISCARD std::string* release_spiffe_id();
  void set_allocated_spiffe_id(std::string* spiffe_id);
  private:
  const std::string& _internal_spiffe_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spiffe_id(const std::string& value);
  std::string* _internal_mutable_spiffe_id();
  public:

  // @@protoc_insertion_point(class_scope:JWTSVIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> audience_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spiffe_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class JWTSVIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JWTSVIDResponse) */ {
 public:
  inline JWTSVIDResponse() : JWTSVIDResponse(nullptr) {}
  ~JWTSVIDResponse() override;
  explicit PROTOBUF_CONSTEXPR JWTSVIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JWTSVIDResponse(const JWTSVIDResponse& from);
  JWTSVIDResponse(JWTSVIDResponse&& from) noexcept
    : JWTSVIDResponse() {
    *this = ::std::move(from);
  }

  inline JWTSVIDResponse& operator=(const JWTSVIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JWTSVIDResponse& operator=(JWTSVIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JWTSVIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JWTSVIDResponse* internal_default_instance() {
    return reinterpret_cast<const JWTSVIDResponse*>(
               &_JWTSVIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(JWTSVIDResponse& a, JWTSVIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JWTSVIDResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JWTSVIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JWTSVIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JWTSVIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JWTSVIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JWTSVIDResponse& from) {
    JWTSVIDResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JWTSVIDResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JWTSVIDResponse";
  }
  protected:
  explicit JWTSVIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSvidsFieldNumber = 1,
  };
  // repeated .JWTSVID svids = 1;
  int svids_size() const;
  private:
  int _internal_svids_size() const;
  public:
  void clear_svids();
  ::JWTSVID* mutable_svids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JWTSVID >*
      mutable_svids();
  private:
  const ::JWTSVID& _internal_svids(int index) const;
  ::JWTSVID* _internal_add_svids();
  public:
  const ::JWTSVID& svids(int index) const;
  ::JWTSVID* add_svids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JWTSVID >&
      svids() const;

  // @@protoc_insertion_point(class_scope:JWTSVIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JWTSVID > svids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class JWTSVID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JWTSVID) */ {
 public:
  inline JWTSVID() : JWTSVID(nullptr) {}
  ~JWTSVID() override;
  explicit PROTOBUF_CONSTEXPR JWTSVID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JWTSVID(const JWTSVID& from);
  JWTSVID(JWTSVID&& from) noexcept
    : JWTSVID() {
    *this = ::std::move(from);
  }

  inline JWTSVID& operator=(const JWTSVID& from) {
    CopyFrom(from);
    return *this;
  }
  inline JWTSVID& operator=(JWTSVID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JWTSVID& default_instance() {
    return *internal_default_instance();
  }
  static inline const JWTSVID* internal_default_instance() {
    return reinterpret_cast<const JWTSVID*>(
               &_JWTSVID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(JWTSVID& a, JWTSVID& b) {
    a.Swap(&b);
  }
  inline void Swap(JWTSVID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JWTSVID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JWTSVID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JWTSVID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JWTSVID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JWTSVID& from) {
    JWTSVID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JWTSVID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JWTSVID";
  }
  protected:
  explicit JWTSVID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpiffeIdFieldNumber = 1,
    kSvidFieldNumber = 2,
    kHintFieldNumber = 3,
  };
  // string spiffe_id = 1;
  void clear_spiffe_id();
  const std::string& spiffe_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spiffe_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spiffe_id();
  PROTOBUF_NODISCARD std::string* release_spiffe_id();
  void set_allocated_spiffe_id(std::string* spiffe_id);
  private:
  const std::string& _internal_spiffe_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spiffe_id(const std::string& value);
  std::string* _internal_mutable_spiffe_id();
  public:

  // string svid = 2;
  void clear_svid();
  const std::string& svid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_svid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_svid();
  PROTOBUF_NODISCARD std::string* release_svid();
  void set_allocated_svid(std::string* svid);
  private:
  const std::string& _internal_svid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_svid(const std::string& value);
  std::string* _internal_mutable_svid();
  public:

  // string hint = 3;
  void clear_hint();
  const std::string& hint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hint();
  PROTOBUF_NODISCARD std::string* release_hint();
  void set_allocated_hint(std::string* hint);
  private:
  const std::string& _internal_hint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hint(const std::string& value);
  std::string* _internal_mutable_hint();
  public:

  // @@protoc_insertion_point(class_scope:JWTSVID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spiffe_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr svid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class JWTBundlesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:JWTBundlesRequest) */ {
 public:
  inline JWTBundlesRequest() : JWTBundlesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR JWTBundlesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JWTBundlesRequest(const JWTBundlesRequest& from);
  JWTBundlesRequest(JWTBundlesRequest&& from) noexcept
    : JWTBundlesRequest() {
    *this = ::std::move(from);
  }

  inline JWTBundlesRequest& operator=(const JWTBundlesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JWTBundlesRequest& operator=(JWTBundlesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JWTBundlesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JWTBundlesRequest* internal_default_instance() {
    return reinterpret_cast<const JWTBundlesRequest*>(
               &_JWTBundlesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(JWTBundlesRequest& a, JWTBundlesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JWTBundlesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JWTBundlesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JWTBundlesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JWTBundlesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const JWTBundlesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const JWTBundlesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JWTBundlesRequest";
  }
  protected:
  explicit JWTBundlesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:JWTBundlesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class JWTBundlesResponse_BundlesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JWTBundlesResponse_BundlesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<JWTBundlesResponse_BundlesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  JWTBundlesResponse_BundlesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR JWTBundlesResponse_BundlesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit JWTBundlesResponse_BundlesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const JWTBundlesResponse_BundlesEntry_DoNotUse& other);
  static const JWTBundlesResponse_BundlesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const JWTBundlesResponse_BundlesEntry_DoNotUse*>(&_JWTBundlesResponse_BundlesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "JWTBundlesResponse.BundlesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};

// -------------------------------------------------------------------

class JWTBundlesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JWTBundlesResponse) */ {
 public:
  inline JWTBundlesResponse() : JWTBundlesResponse(nullptr) {}
  ~JWTBundlesResponse() override;
  explicit PROTOBUF_CONSTEXPR JWTBundlesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JWTBundlesResponse(const JWTBundlesResponse& from);
  JWTBundlesResponse(JWTBundlesResponse&& from) noexcept
    : JWTBundlesResponse() {
    *this = ::std::move(from);
  }

  inline JWTBundlesResponse& operator=(const JWTBundlesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JWTBundlesResponse& operator=(JWTBundlesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JWTBundlesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JWTBundlesResponse* internal_default_instance() {
    return reinterpret_cast<const JWTBundlesResponse*>(
               &_JWTBundlesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(JWTBundlesResponse& a, JWTBundlesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JWTBundlesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JWTBundlesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JWTBundlesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JWTBundlesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JWTBundlesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JWTBundlesResponse& from) {
    JWTBundlesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JWTBundlesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JWTBundlesResponse";
  }
  protected:
  explicit JWTBundlesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kBundlesFieldNumber = 1,
  };
  // map<string, bytes> bundles = 1;
  int bundles_size() const;
  private:
  int _internal_bundles_size() const;
  public:
  void clear_bundles();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_bundles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_bundles();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      bundles() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_bundles();

  // @@protoc_insertion_point(class_scope:JWTBundlesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        JWTBundlesResponse_BundlesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> bundles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class ValidateJWTSVIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ValidateJWTSVIDRequest) */ {
 public:
  inline ValidateJWTSVIDRequest() : ValidateJWTSVIDRequest(nullptr) {}
  ~ValidateJWTSVIDRequest() override;
  explicit PROTOBUF_CONSTEXPR ValidateJWTSVIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateJWTSVIDRequest(const ValidateJWTSVIDRequest& from);
  ValidateJWTSVIDRequest(ValidateJWTSVIDRequest&& from) noexcept
    : ValidateJWTSVIDRequest() {
    *this = ::std::move(from);
  }

  inline ValidateJWTSVIDRequest& operator=(const ValidateJWTSVIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateJWTSVIDRequest& operator=(ValidateJWTSVIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateJWTSVIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateJWTSVIDRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateJWTSVIDRequest*>(
               &_ValidateJWTSVIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ValidateJWTSVIDRequest& a, ValidateJWTSVIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateJWTSVIDRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateJWTSVIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateJWTSVIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateJWTSVIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateJWTSVIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateJWTSVIDRequest& from) {
    ValidateJWTSVIDRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateJWTSVIDRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ValidateJWTSVIDRequest";
  }
  protected:
  explicit ValidateJWTSVIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudienceFieldNumber = 1,
    kSvidFieldNumber = 2,
  };
  // string audience = 1;
  void clear_audience();
  const std::string& audience() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audience(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audience();
  PROTOBUF_NODISCARD std::string* release_audience();
  void set_allocated_audience(std::string* audience);
  private:
  const std::string& _internal_audience() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audience(const std::string& value);
  std::string* _internal_mutable_audience();
  public:

  // string svid = 2;
  void clear_svid();
  const std::string& svid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_svid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_svid();
  PROTOBUF_NODISCARD std::string* release_svid();
  void set_allocated_svid(std::string* svid);
  private:
  const std::string& _internal_svid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_svid(const std::string& value);
  std::string* _internal_mutable_svid();
  public:

  // @@protoc_insertion_point(class_scope:ValidateJWTSVIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audience_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr svid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// -------------------------------------------------------------------

class ValidateJWTSVIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ValidateJWTSVIDResponse) */ {
 public:
  inline ValidateJWTSVIDResponse() : ValidateJWTSVIDResponse(nullptr) {}
  ~ValidateJWTSVIDResponse() override;
  explicit PROTOBUF_CONSTEXPR ValidateJWTSVIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateJWTSVIDResponse(const ValidateJWTSVIDResponse& from);
  ValidateJWTSVIDResponse(ValidateJWTSVIDResponse&& from) noexcept
    : ValidateJWTSVIDResponse() {
    *this = ::std::move(from);
  }

  inline ValidateJWTSVIDResponse& operator=(const ValidateJWTSVIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateJWTSVIDResponse& operator=(ValidateJWTSVIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateJWTSVIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateJWTSVIDResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateJWTSVIDResponse*>(
               &_ValidateJWTSVIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ValidateJWTSVIDResponse& a, ValidateJWTSVIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateJWTSVIDResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateJWTSVIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateJWTSVIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateJWTSVIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateJWTSVIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateJWTSVIDResponse& from) {
    ValidateJWTSVIDResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateJWTSVIDResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ValidateJWTSVIDResponse";
  }
  protected:
  explicit ValidateJWTSVIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpiffeIdFieldNumber = 1,
    kClaimsFieldNumber = 2,
  };
  // string spiffe_id = 1;
  void clear_spiffe_id();
  const std::string& spiffe_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spiffe_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spiffe_id();
  PROTOBUF_NODISCARD std::string* release_spiffe_id();
  void set_allocated_spiffe_id(std::string* spiffe_id);
  private:
  const std::string& _internal_spiffe_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spiffe_id(const std::string& value);
  std::string* _internal_mutable_spiffe_id();
  public:

  // .google.protobuf.Struct claims = 2;
  bool has_claims() const;
  private:
  bool _internal_has_claims() const;
  public:
  void clear_claims();
  const ::PROTOBUF_NAMESPACE_ID::Struct& claims() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_claims();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_claims();
  void set_allocated_claims(::PROTOBUF_NAMESPACE_ID::Struct* claims);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_claims() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_claims();
  public:
  void unsafe_arena_set_allocated_claims(
      ::PROTOBUF_NAMESPACE_ID::Struct* claims);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_claims();

  // @@protoc_insertion_point(class_scope:ValidateJWTSVIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spiffe_id_;
    ::PROTOBUF_NAMESPACE_ID::Struct* claims_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spiffe_2fworkload_2fworkload_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// X509SVIDRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// X509SVIDResponse

// repeated .X509SVID svids = 1;
inline int X509SVIDResponse::_internal_svids_size() const {
  return _impl_.svids_.size();
}
inline int X509SVIDResponse::svids_size() const {
  return _internal_svids_size();
}
inline void X509SVIDResponse::clear_svids() {
  _impl_.svids_.Clear();
}
inline ::X509SVID* X509SVIDResponse::mutable_svids(int index) {
  // @@protoc_insertion_point(field_mutable:X509SVIDResponse.svids)
  return _impl_.svids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::X509SVID >*
X509SVIDResponse::mutable_svids() {
  // @@protoc_insertion_point(field_mutable_list:X509SVIDResponse.svids)
  return &_impl_.svids_;
}
inline const ::X509SVID& X509SVIDResponse::_internal_svids(int index) const {
  return _impl_.svids_.Get(index);
}
inline const ::X509SVID& X509SVIDResponse::svids(int index) const {
  // @@protoc_insertion_point(field_get:X509SVIDResponse.svids)
  return _internal_svids(index);
}
inline ::X509SVID* X509SVIDResponse::_internal_add_svids() {
  return _impl_.svids_.Add();
}
inline ::X509SVID* X509SVIDResponse::add_svids() {
  ::X509SVID* _add = _internal_add_svids();
  // @@protoc_insertion_point(field_add:X509SVIDResponse.svids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::X509SVID >&
X509SVIDResponse::svids() const {
  // @@protoc_insertion_point(field_list:X509SVIDResponse.svids)
  return _impl_.svids_;
}

// repeated bytes crl = 2;
inline int X509SVIDResponse::_internal_crl_size() const {
  return _impl_.crl_.size();
}
inline int X509SVIDResponse::crl_size() const {
  return _internal_crl_size();
}
inline void X509SVIDResponse::clear_crl() {
  _impl_.crl_.Clear();
}
inline std::string* X509SVIDResponse::add_crl() {
  std::string* _s = _internal_add_crl();
  // @@protoc_insertion_point(field_add_mutable:X509SVIDResponse.crl)
  return _s;
}
inline const std::string& X509SVIDResponse::_internal_crl(int index) const {
  return _impl_.crl_.Get(index);
}
inline const std::string& X509SVIDResponse::crl(int index) const {
  // @@protoc_insertion_point(field_get:X509SVIDResponse.crl)
  return _internal_crl(index);
}
inline std::string* X509SVIDResponse::mutable_crl(int index) {
  // @@protoc_insertion_point(field_mutable:X509SVIDResponse.crl)
  return _impl_.crl_.Mutable(index);
}
inline void X509SVIDResponse::set_crl(int index, const std::string& value) {
  _impl_.crl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:X509SVIDResponse.crl)
}
inline void X509SVIDResponse::set_crl(int index, std::string&& value) {
  _impl_.crl_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:X509SVIDResponse.crl)
}
inline void X509SVIDResponse::set_crl(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.crl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:X509SVIDResponse.crl)
}
inline void X509SVIDResponse::set_crl(int index, const void* value, size_t size) {
  _impl_.crl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:X509SVIDResponse.crl)
}
inline std::string* X509SVIDResponse::_internal_add_crl() {
  return _impl_.crl_.Add();
}
inline void X509SVIDResponse::add_crl(const std::string& value) {
  _impl_.crl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:X509SVIDResponse.crl)
}
inline void X509SVIDResponse::add_crl(std::string&& value) {
  _impl_.crl_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:X509SVIDResponse.crl)
}
inline void X509SVIDResponse::add_crl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.crl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:X509SVIDResponse.crl)
}
inline void X509SVIDResponse::add_crl(const void* value, size_t size) {
  _impl_.crl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:X509SVIDResponse.crl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
X509SVIDResponse::crl() const {
  // @@protoc_insertion_point(field_list:X509SVIDResponse.crl)
  return _impl_.crl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
X509SVIDResponse::mutable_crl() {
  // @@protoc_insertion_point(field_mutable_list:X509SVIDResponse.crl)
  return &_impl_.crl_;
}

// map<string, bytes> federated_bundles = 3;
inline int X509SVIDResponse::_internal_federated_bundles_size() const {
  return _impl_.federated_bundles_.size();
}
inline int X509SVIDResponse::federated_bundles_size() const {
  return _internal_federated_bundles_size();
}
inline void X509SVIDResponse::clear_federated_bundles() {
  _impl_.federated_bundles_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
X509SVIDResponse::_internal_federated_bundles() const {
  return _impl_.federated_bundles_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
X509SVIDResponse::federated_bundles() const {
  // @@protoc_insertion_point(field_map:X509SVIDResponse.federated_bundles)
  return _internal_federated_bundles();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
X509SVIDResponse::_internal_mutable_federated_bundles() {
  return _impl_.federated_bundles_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
X509SVIDResponse::mutable_federated_bundles() {
  // @@protoc_insertion_point(field_mutable_map:X509SVIDResponse.federated_bundles)
  return _internal_mutable_federated_bundles();
}

// -------------------------------------------------------------------

// X509SVID

// string spiffe_id = 1;
inline void X509SVID::clear_spiffe_id() {
  _impl_.spiffe_id_.ClearToEmpty();
}
inline const std::string& X509SVID::spiffe_id() const {
  // @@protoc_insertion_point(field_get:X509SVID.spiffe_id)
  return _internal_spiffe_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void X509SVID::set_spiffe_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spiffe_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:X509SVID.spiffe_id)
}
inline std::string* X509SVID::mutable_spiffe_id() {
  std::string* _s = _internal_mutable_spiffe_id();
  // @@protoc_insertion_point(field_mutable:X509SVID.spiffe_id)
  return _s;
}
inline const std::string& X509SVID::_internal_spiffe_id() const {
  return _impl_.spiffe_id_.Get();
}
inline void X509SVID::_internal_set_spiffe_id(const std::string& value) {
  
  _impl_.spiffe_id_.Set(value, GetArenaForAllocation());
}
inline std::string* X509SVID::_internal_mutable_spiffe_id() {
  
  return _impl_.spiffe_id_.Mutable(GetArenaForAllocation());
}
inline std::string* X509SVID::release_spiffe_id() {
  // @@protoc_insertion_point(field_release:X509SVID.spiffe_id)
  return _impl_.spiffe_id_.Release();
}
inline void X509SVID::set_allocated_spiffe_id(std::string* spiffe_id) {
  if (spiffe_id != nullptr) {
    
  } else {
    
  }
  _impl_.spiffe_id_.SetAllocated(spiffe_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spiffe_id_.IsDefault()) {
    _impl_.spiffe_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:X509SVID.spiffe_id)
}

// bytes x509_svid = 2;
inline void X509SVID::clear_x509_svid() {
  _impl_.x509_svid_.ClearToEmpty();
}
inline const std::string& X509SVID::x509_svid() const {
  // @@protoc_insertion_point(field_get:X509SVID.x509_svid)
  return _internal_x509_svid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void X509SVID::set_x509_svid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.x509_svid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:X509SVID.x509_svid)
}
inline std::string* X509SVID::mutable_x509_svid() {
  std::string* _s = _internal_mutable_x509_svid();
  // @@protoc_insertion_point(field_mutable:X509SVID.x509_svid)
  return _s;
}
inline const std::string& X509SVID::_internal_x509_svid() const {
  return _impl_.x509_svid_.Get();
}
inline void X509SVID::_internal_set_x509_svid(const std::string& value) {
  
  _impl_.x509_svid_.Set(value, GetArenaForAllocation());
}
inline std::string* X509SVID::_internal_mutable_x509_svid() {
  
  return _impl_.x509_svid_.Mutable(GetArenaForAllocation());
}
inline std::string* X509SVID::release_x509_svid() {
  // @@protoc_insertion_point(field_release:X509SVID.x509_svid)
  return _impl_.x509_svid_.Release();
}
inline void X509SVID::set_allocated_x509_svid(std::string* x509_svid) {
  if (x509_svid != nullptr) {
    
  } else {
    
  }
  _impl_.x509_svid_.SetAllocated(x509_svid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.x509_svid_.IsDefault()) {
    _impl_.x509_svid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:X509SVID.x509_svid)
}

// bytes x509_svid_key = 3;
inline void X509SVID::clear_x509_svid_key() {
  _impl_.x509_svid_key_.ClearToEmpty();
}
inline const std::string& X509SVID::x509_svid_key() const {
  // @@protoc_insertion_point(field_get:X509SVID.x509_svid_key)
  return _internal_x509_svid_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void X509SVID::set_x509_svid_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.x509_svid_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:X509SVID.x509_svid_key)
}
inline std::string* X509SVID::mutable_x509_svid_key() {
  std::string* _s = _internal_mutable_x509_svid_key();
  // @@protoc_insertion_point(field_mutable:X509SVID.x509_svid_key)
  return _s;
}
inline const std::string& X509SVID::_internal_x509_svid_key() const {
  return _impl_.x509_svid_key_.Get();
}
inline void X509SVID::_internal_set_x509_svid_key(const std::string& value) {
  
  _impl_.x509_svid_key_.Set(value, GetArenaForAllocation());
}
inline std::string* X509SVID::_internal_mutable_x509_svid_key() {
  
  return _impl_.x509_svid_key_.Mutable(GetArenaForAllocation());
}
inline std::string* X509SVID::release_x509_svid_key() {
  // @@protoc_insertion_point(field_release:X509SVID.x509_svid_key)
  return _impl_.x509_svid_key_.Release();
}
inline void X509SVID::set_allocated_x509_svid_key(std::string* x509_svid_key) {
  if (x509_svid_key != nullptr) {
    
  } else {
    
  }
  _impl_.x509_svid_key_.SetAllocated(x509_svid_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.x509_svid_key_.IsDefault()) {
    _impl_.x509_svid_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:X509SVID.x509_svid_key)
}

// bytes bundle = 4;
inline void X509SVID::clear_bundle() {
  _impl_.bundle_.ClearToEmpty();
}
inline const std::string& X509SVID::bundle() const {
  // @@protoc_insertion_point(field_get:X509SVID.bundle)
  return _internal_bundle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void X509SVID::set_bundle(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bundle_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:X509SVID.bundle)
}
inline std::string* X509SVID::mutable_bundle() {
  std::string* _s = _internal_mutable_bundle();
  // @@protoc_insertion_point(field_mutable:X509SVID.bundle)
  return _s;
}
inline const std::string& X509SVID::_internal_bundle() const {
  return _impl_.bundle_.Get();
}
inline void X509SVID::_internal_set_bundle(const std::string& value) {
  
  _impl_.bundle_.Set(value, GetArenaForAllocation());
}
inline std::string* X509SVID::_internal_mutable_bundle() {
  
  return _impl_.bundle_.Mutable(GetArenaForAllocation());
}
inline std::string* X509SVID::release_bundle() {
  // @@protoc_insertion_point(field_release:X509SVID.bundle)
  return _impl_.bundle_.Release();
}
inline void X509SVID::set_allocated_bundle(std::string* bundle) {
  if (bundle != nullptr) {
    
  } else {
    
  }
  _impl_.bundle_.SetAllocated(bundle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bundle_.IsDefault()) {
    _impl_.bundle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:X509SVID.bundle)
}

// string hint = 5;
inline void X509SVID::clear_hint() {
  _impl_.hint_.ClearToEmpty();
}
inline const std::string& X509SVID::hint() const {
  // @@protoc_insertion_point(field_get:X509SVID.hint)
  return _internal_hint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void X509SVID::set_hint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:X509SVID.hint)
}
inline std::string* X509SVID::mutable_hint() {
  std::string* _s = _internal_mutable_hint();
  // @@protoc_insertion_point(field_mutable:X509SVID.hint)
  return _s;
}
inline const std::string& X509SVID::_internal_hint() const {
  return _impl_.hint_.Get();
}
inline void X509SVID::_internal_set_hint(const std::string& value) {
  
  _impl_.hint_.Set(value, GetArenaForAllocation());
}
inline std::string* X509SVID::_internal_mutable_hint() {
  
  return _impl_.hint_.Mutable(GetArenaForAllocation());
}
inline std::string* X509SVID::release_hint() {
  // @@protoc_insertion_point(field_release:X509SVID.hint)
  return _impl_.hint_.Release();
}
inline void X509SVID::set_allocated_hint(std::string* hint) {
  if (hint != nullptr) {
    
  } else {
    
  }
  _impl_.hint_.SetAllocated(hint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hint_.IsDefault()) {
    _impl_.hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:X509SVID.hint)
}

// -------------------------------------------------------------------

// X509BundlesRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// X509BundlesResponse

// repeated bytes crl = 1;
inline int X509BundlesResponse::_internal_crl_size() const {
  return _impl_.crl_.size();
}
inline int X509BundlesResponse::crl_size() const {
  return _internal_crl_size();
}
inline void X509BundlesResponse::clear_crl() {
  _impl_.crl_.Clear();
}
inline std::string* X509BundlesResponse::add_crl() {
  std::string* _s = _internal_add_crl();
  // @@protoc_insertion_point(field_add_mutable:X509BundlesResponse.crl)
  return _s;
}
inline const std::string& X509BundlesResponse::_internal_crl(int index) const {
  return _impl_.crl_.Get(index);
}
inline const std::string& X509BundlesResponse::crl(int index) const {
  // @@protoc_insertion_point(field_get:X509BundlesResponse.crl)
  return _internal_crl(index);
}
inline std::string* X509BundlesResponse::mutable_crl(int index) {
  // @@protoc_insertion_point(field_mutable:X509BundlesResponse.crl)
  return _impl_.crl_.Mutable(index);
}
inline void X509BundlesResponse::set_crl(int index, const std::string& value) {
  _impl_.crl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:X509BundlesResponse.crl)
}
inline void X509BundlesResponse::set_crl(int index, std::string&& value) {
  _impl_.crl_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:X509BundlesResponse.crl)
}
inline void X509BundlesResponse::set_crl(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.crl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:X509BundlesResponse.crl)
}
inline void X509BundlesResponse::set_crl(int index, const void* value, size_t size) {
  _impl_.crl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:X509BundlesResponse.crl)
}
inline std::string* X509BundlesResponse::_internal_add_crl() {
  return _impl_.crl_.Add();
}
inline void X509BundlesResponse::add_crl(const std::string& value) {
  _impl_.crl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:X509BundlesResponse.crl)
}
inline void X509BundlesResponse::add_crl(std::string&& value) {
  _impl_.crl_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:X509BundlesResponse.crl)
}
inline void X509BundlesResponse::add_crl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.crl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:X509BundlesResponse.crl)
}
inline void X509BundlesResponse::add_crl(const void* value, size_t size) {
  _impl_.crl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:X509BundlesResponse.crl)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
X509BundlesResponse::crl() const {
  // @@protoc_insertion_point(field_list:X509BundlesResponse.crl)
  return _impl_.crl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
X509BundlesResponse::mutable_crl() {
  // @@protoc_insertion_point(field_mutable_list:X509BundlesResponse.crl)
  return &_impl_.crl_;
}

// map<string, bytes> bundles = 2;
inline int X509BundlesResponse::_internal_bundles_size() const {
  return _impl_.bundles_.size();
}
inline int X509BundlesResponse::bundles_size() const {
  return _internal_bundles_size();
}
inline void X509BundlesResponse::clear_bundles() {
  _impl_.bundles_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
X509BundlesResponse::_internal_bundles() const {
  return _impl_.bundles_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
X509BundlesResponse::bundles() const {
  // @@protoc_insertion_point(field_map:X509BundlesResponse.bundles)
  return _internal_bundles();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
X509BundlesResponse::_internal_mutable_bundles() {
  return _impl_.bundles_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
X509BundlesResponse::mutable_bundles() {
  // @@protoc_insertion_point(field_mutable_map:X509BundlesResponse.bundles)
  return _internal_mutable_bundles();
}

// -------------------------------------------------------------------

// JWTSVIDRequest

// repeated string audience = 1;
inline int JWTSVIDRequest::_internal_audience_size() const {
  return _impl_.audience_.size();
}
inline int JWTSVIDRequest::audience_size() const {
  return _internal_audience_size();
}
inline void JWTSVIDRequest::clear_audience() {
  _impl_.audience_.Clear();
}
inline std::string* JWTSVIDRequest::add_audience() {
  std::string* _s = _internal_add_audience();
  // @@protoc_insertion_point(field_add_mutable:JWTSVIDRequest.audience)
  return _s;
}
inline const std::string& JWTSVIDRequest::_internal_audience(int index) const {
  return _impl_.audience_.Get(index);
}
inline const std::string& JWTSVIDRequest::audience(int index) const {
  // @@protoc_insertion_point(field_get:JWTSVIDRequest.audience)
  return _internal_audience(index);
}
inline std::string* JWTSVIDRequest::mutable_audience(int index) {
  // @@protoc_insertion_point(field_mutable:JWTSVIDRequest.audience)
  return _impl_.audience_.Mutable(index);
}
inline void JWTSVIDRequest::set_audience(int index, const std::string& value) {
  _impl_.audience_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:JWTSVIDRequest.audience)
}
inline void JWTSVIDRequest::set_audience(int index, std::string&& value) {
  _impl_.audience_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:JWTSVIDRequest.audience)
}
inline void JWTSVIDRequest::set_audience(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.audience_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:JWTSVIDRequest.audience)
}
inline void JWTSVIDRequest::set_audience(int index, const char* value, size_t size) {
  _impl_.audience_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JWTSVIDRequest.audience)
}
inline std::string* JWTSVIDRequest::_internal_add_audience() {
  return _impl_.audience_.Add();
}
inline void JWTSVIDRequest::add_audience(const std::string& value) {
  _impl_.audience_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:JWTSVIDRequest.audience)
}
inline void JWTSVIDRequest::add_audience(std::string&& value) {
  _impl_.audience_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:JWTSVIDRequest.audience)
}
inline void JWTSVIDRequest::add_audience(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.audience_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:JWTSVIDRequest.audience)
}
inline void JWTSVIDRequest::add_audience(const char* value, size_t size) {
  _impl_.audience_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:JWTSVIDRequest.audience)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JWTSVIDRequest::audience() const {
  // @@protoc_insertion_point(field_list:JWTSVIDRequest.audience)
  return _impl_.audience_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JWTSVIDRequest::mutable_audience() {
  // @@protoc_insertion_point(field_mutable_list:JWTSVIDRequest.audience)
  return &_impl_.audience_;
}

// string spiffe_id = 2;
inline void JWTSVIDRequest::clear_spiffe_id() {
  _impl_.spiffe_id_.ClearToEmpty();
}
inline const std::string& JWTSVIDRequest::spiffe_id() const {
  // @@protoc_insertion_point(field_get:JWTSVIDRequest.spiffe_id)
  return _internal_spiffe_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JWTSVIDRequest::set_spiffe_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spiffe_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JWTSVIDRequest.spiffe_id)
}
inline std::string* JWTSVIDRequest::mutable_spiffe_id() {
  std::string* _s = _internal_mutable_spiffe_id();
  // @@protoc_insertion_point(field_mutable:JWTSVIDRequest.spiffe_id)
  return _s;
}
inline const std::string& JWTSVIDRequest::_internal_spiffe_id() const {
  return _impl_.spiffe_id_.Get();
}
inline void JWTSVIDRequest::_internal_set_spiffe_id(const std::string& value) {
  
  _impl_.spiffe_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JWTSVIDRequest::_internal_mutable_spiffe_id() {
  
  return _impl_.spiffe_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JWTSVIDRequest::release_spiffe_id() {
  // @@protoc_insertion_point(field_release:JWTSVIDRequest.spiffe_id)
  return _impl_.spiffe_id_.Release();
}
inline void JWTSVIDRequest::set_allocated_spiffe_id(std::string* spiffe_id) {
  if (spiffe_id != nullptr) {
    
  } else {
    
  }
  _impl_.spiffe_id_.SetAllocated(spiffe_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spiffe_id_.IsDefault()) {
    _impl_.spiffe_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JWTSVIDRequest.spiffe_id)
}

// -------------------------------------------------------------------

// JWTSVIDResponse

// repeated .JWTSVID svids = 1;
inline int JWTSVIDResponse::_internal_svids_size() const {
  return _impl_.svids_.size();
}
inline int JWTSVIDResponse::svids_size() const {
  return _internal_svids_size();
}
inline void JWTSVIDResponse::clear_svids() {
  _impl_.svids_.Clear();
}
inline ::JWTSVID* JWTSVIDResponse::mutable_svids(int index) {
  // @@protoc_insertion_point(field_mutable:JWTSVIDResponse.svids)
  return _impl_.svids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JWTSVID >*
JWTSVIDResponse::mutable_svids() {
  // @@protoc_insertion_point(field_mutable_list:JWTSVIDResponse.svids)
  return &_impl_.svids_;
}
inline const ::JWTSVID& JWTSVIDResponse::_internal_svids(int index) const {
  return _impl_.svids_.Get(index);
}
inline const ::JWTSVID& JWTSVIDResponse::svids(int index) const {
  // @@protoc_insertion_point(field_get:JWTSVIDResponse.svids)
  return _internal_svids(index);
}
inline ::JWTSVID* JWTSVIDResponse::_internal_add_svids() {
  return _impl_.svids_.Add();
}
inline ::JWTSVID* JWTSVIDResponse::add_svids() {
  ::JWTSVID* _add = _internal_add_svids();
  // @@protoc_insertion_point(field_add:JWTSVIDResponse.svids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::JWTSVID >&
JWTSVIDResponse::svids() const {
  // @@protoc_insertion_point(field_list:JWTSVIDResponse.svids)
  return _impl_.svids_;
}

// -------------------------------------------------------------------

// JWTSVID

// string spiffe_id = 1;
inline void JWTSVID::clear_spiffe_id() {
  _impl_.spiffe_id_.ClearToEmpty();
}
inline const std::string& JWTSVID::spiffe_id() const {
  // @@protoc_insertion_point(field_get:JWTSVID.spiffe_id)
  return _internal_spiffe_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JWTSVID::set_spiffe_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spiffe_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JWTSVID.spiffe_id)
}
inline std::string* JWTSVID::mutable_spiffe_id() {
  std::string* _s = _internal_mutable_spiffe_id();
  // @@protoc_insertion_point(field_mutable:JWTSVID.spiffe_id)
  return _s;
}
inline const std::string& JWTSVID::_internal_spiffe_id() const {
  return _impl_.spiffe_id_.Get();
}
inline void JWTSVID::_internal_set_spiffe_id(const std::string& value) {
  
  _impl_.spiffe_id_.Set(value, GetArenaForAllocation());
}
inline std::string* JWTSVID::_internal_mutable_spiffe_id() {
  
  return _impl_.spiffe_id_.Mutable(GetArenaForAllocation());
}
inline std::string* JWTSVID::release_spiffe_id() {
  // @@protoc_insertion_point(field_release:JWTSVID.spiffe_id)
  return _impl_.spiffe_id_.Release();
}
inline void JWTSVID::set_allocated_spiffe_id(std::string* spiffe_id) {
  if (spiffe_id != nullptr) {
    
  } else {
    
  }
  _impl_.spiffe_id_.SetAllocated(spiffe_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spiffe_id_.IsDefault()) {
    _impl_.spiffe_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JWTSVID.spiffe_id)
}

// string svid = 2;
inline void JWTSVID::clear_svid() {
  _impl_.svid_.ClearToEmpty();
}
inline const std::string& JWTSVID::svid() const {
  // @@protoc_insertion_point(field_get:JWTSVID.svid)
  return _internal_svid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JWTSVID::set_svid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.svid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JWTSVID.svid)
}
inline std::string* JWTSVID::mutable_svid() {
  std::string* _s = _internal_mutable_svid();
  // @@protoc_insertion_point(field_mutable:JWTSVID.svid)
  return _s;
}
inline const std::string& JWTSVID::_internal_svid() const {
  return _impl_.svid_.Get();
}
inline void JWTSVID::_internal_set_svid(const std::string& value) {
  
  _impl_.svid_.Set(value, GetArenaForAllocation());
}
inline std::string* JWTSVID::_internal_mutable_svid() {
  
  return _impl_.svid_.Mutable(GetArenaForAllocation());
}
inline std::string* JWTSVID::release_svid() {
  // @@protoc_insertion_point(field_release:JWTSVID.svid)
  return _impl_.svid_.Release();
}
inline void JWTSVID::set_allocated_svid(std::string* svid) {
  if (svid != nullptr) {
    
  } else {
    
  }
  _impl_.svid_.SetAllocated(svid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.svid_.IsDefault()) {
    _impl_.svid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JWTSVID.svid)
}

// string hint = 3;
inline void JWTSVID::clear_hint() {
  _impl_.hint_.ClearToEmpty();
}
inline const std::string& JWTSVID::hint() const {
  // @@protoc_insertion_point(field_get:JWTSVID.hint)
  return _internal_hint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JWTSVID::set_hint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:JWTSVID.hint)
}
inline std::string* JWTSVID::mutable_hint() {
  std::string* _s = _internal_mutable_hint();
  // @@protoc_insertion_point(field_mutable:JWTSVID.hint)
  return _s;
}
inline const std::string& JWTSVID::_internal_hint() const {
  return _impl_.hint_.Get();
}
inline void JWTSVID::_internal_set_hint(const std::string& value) {
  
  _impl_.hint_.Set(value, GetArenaForAllocation());
}
inline std::string* JWTSVID::_internal_mutable_hint() {
  
  return _impl_.hint_.Mutable(GetArenaForAllocation());
}
inline std::string* JWTSVID::release_hint() {
  // @@protoc_insertion_point(field_release:JWTSVID.hint)
  return _impl_.hint_.Release();
}
inline void JWTSVID::set_allocated_hint(std::string* hint) {
  if (hint != nullptr) {
    
  } else {
    
  }
  _impl_.hint_.SetAllocated(hint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hint_.IsDefault()) {
    _impl_.hint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:JWTSVID.hint)
}

// -------------------------------------------------------------------

// JWTBundlesRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// JWTBundlesResponse

// map<string, bytes> bundles = 1;
inline int JWTBundlesResponse::_internal_bundles_size() const {
  return _impl_.bundles_.size();
}
inline int JWTBundlesResponse::bundles_size() const {
  return _internal_bundles_size();
}
inline void JWTBundlesResponse::clear_bundles() {
  _impl_.bundles_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JWTBundlesResponse::_internal_bundles() const {
  return _impl_.bundles_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
JWTBundlesResponse::bundles() const {
  // @@protoc_insertion_point(field_map:JWTBundlesResponse.bundles)
  return _internal_bundles();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JWTBundlesResponse::_internal_mutable_bundles() {
  return _impl_.bundles_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
JWTBundlesResponse::mutable_bundles() {
  // @@protoc_insertion_point(field_mutable_map:JWTBundlesResponse.bundles)
  return _internal_mutable_bundles();
}

// -------------------------------------------------------------------

// ValidateJWTSVIDRequest

// string audience = 1;
inline void ValidateJWTSVIDRequest::clear_audience() {
  _impl_.audience_.ClearToEmpty();
}
inline const std::string& ValidateJWTSVIDRequest::audience() const {
  // @@protoc_insertion_point(field_get:ValidateJWTSVIDRequest.audience)
  return _internal_audience();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateJWTSVIDRequest::set_audience(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audience_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ValidateJWTSVIDRequest.audience)
}
inline std::string* ValidateJWTSVIDRequest::mutable_audience() {
  std::string* _s = _internal_mutable_audience();
  // @@protoc_insertion_point(field_mutable:ValidateJWTSVIDRequest.audience)
  return _s;
}
inline const std::string& ValidateJWTSVIDRequest::_internal_audience() const {
  return _impl_.audience_.Get();
}
inline void ValidateJWTSVIDRequest::_internal_set_audience(const std::string& value) {
  
  _impl_.audience_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateJWTSVIDRequest::_internal_mutable_audience() {
  
  return _impl_.audience_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateJWTSVIDRequest::release_audience() {
  // @@protoc_insertion_point(field_release:ValidateJWTSVIDRequest.audience)
  return _impl_.audience_.Release();
}
inline void ValidateJWTSVIDRequest::set_allocated_audience(std::string* audience) {
  if (audience != nullptr) {
    
  } else {
    
  }
  _impl_.audience_.SetAllocated(audience, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audience_.IsDefault()) {
    _impl_.audience_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ValidateJWTSVIDRequest.audience)
}

// string svid = 2;
inline void ValidateJWTSVIDRequest::clear_svid() {
  _impl_.svid_.ClearToEmpty();
}
inline const std::string& ValidateJWTSVIDRequest::svid() const {
  // @@protoc_insertion_point(field_get:ValidateJWTSVIDRequest.svid)
  return _internal_svid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateJWTSVIDRequest::set_svid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.svid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ValidateJWTSVIDRequest.svid)
}
inline std::string* ValidateJWTSVIDRequest::mutable_svid() {
  std::string* _s = _internal_mutable_svid();
  // @@protoc_insertion_point(field_mutable:ValidateJWTSVIDRequest.svid)
  return _s;
}
inline const std::string& ValidateJWTSVIDRequest::_internal_svid() const {
  return _impl_.svid_.Get();
}
inline void ValidateJWTSVIDRequest::_internal_set_svid(const std::string& value) {
  
  _impl_.svid_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateJWTSVIDRequest::_internal_mutable_svid() {
  
  return _impl_.svid_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateJWTSVIDRequest::release_svid() {
  // @@protoc_insertion_point(field_release:ValidateJWTSVIDRequest.svid)
  return _impl_.svid_.Release();
}
inline void ValidateJWTSVIDRequest::set_allocated_svid(std::string* svid) {
  if (svid != nullptr) {
    
  } else {
    
  }
  _impl_.svid_.SetAllocated(svid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.svid_.IsDefault()) {
    _impl_.svid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ValidateJWTSVIDRequest.svid)
}

// -------------------------------------------------------------------

// ValidateJWTSVIDResponse

// string spiffe_id = 1;
inline void ValidateJWTSVIDResponse::clear_spiffe_id() {
  _impl_.spiffe_id_.ClearToEmpty();
}
inline const std::string& ValidateJWTSVIDResponse::spiffe_id() const {
  // @@protoc_insertion_point(field_get:ValidateJWTSVIDResponse.spiffe_id)
  return _internal_spiffe_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateJWTSVIDResponse::set_spiffe_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.spiffe_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ValidateJWTSVIDResponse.spiffe_id)
}
inline std::string* ValidateJWTSVIDResponse::mutable_spiffe_id() {
  std::string* _s = _internal_mutable_spiffe_id();
  // @@protoc_insertion_point(field_mutable:ValidateJWTSVIDResponse.spiffe_id)
  return _s;
}
inline const std::string& ValidateJWTSVIDResponse::_internal_spiffe_id() const {
  return _impl_.spiffe_id_.Get();
}
inline void ValidateJWTSVIDResponse::_internal_set_spiffe_id(const std::string& value) {
  
  _impl_.spiffe_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateJWTSVIDResponse::_internal_mutable_spiffe_id() {
  
  return _impl_.spiffe_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateJWTSVIDResponse::release_spiffe_id() {
  // @@protoc_insertion_point(field_release:ValidateJWTSVIDResponse.spiffe_id)
  return _impl_.spiffe_id_.Release();
}
inline void ValidateJWTSVIDResponse::set_allocated_spiffe_id(std::string* spiffe_id) {
  if (spiffe_id != nullptr) {
    
  } else {
    
  }
  _impl_.spiffe_id_.SetAllocated(spiffe_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.spiffe_id_.IsDefault()) {
    _impl_.spiffe_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ValidateJWTSVIDResponse.spiffe_id)
}

// .google.protobuf.Struct claims = 2;
inline bool ValidateJWTSVIDResponse::_internal_has_claims() const {
  return this != internal_default_instance() && _impl_.claims_ != nullptr;
}
inline bool ValidateJWTSVIDResponse::has_claims() const {
  return _internal_has_claims();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ValidateJWTSVIDResponse::_internal_claims() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.claims_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& ValidateJWTSVIDResponse::claims() const {
  // @@protoc_insertion_point(field_get:ValidateJWTSVIDResponse.claims)
  return _internal_claims();
}
inline void ValidateJWTSVIDResponse::unsafe_arena_set_allocated_claims(
    ::PROTOBUF_NAMESPACE_ID::Struct* claims) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claims_);
  }
  _impl_.claims_ = claims;
  if (claims) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ValidateJWTSVIDResponse.claims)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ValidateJWTSVIDResponse::release_claims() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.claims_;
  _impl_.claims_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ValidateJWTSVIDResponse::unsafe_arena_release_claims() {
  // @@protoc_insertion_point(field_release:ValidateJWTSVIDResponse.claims)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.claims_;
  _impl_.claims_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ValidateJWTSVIDResponse::_internal_mutable_claims() {
  
  if (_impl_.claims_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.claims_ = p;
  }
  return _impl_.claims_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* ValidateJWTSVIDResponse::mutable_claims() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_claims();
  // @@protoc_insertion_point(field_mutable:ValidateJWTSVIDResponse.claims)
  return _msg;
}
inline void ValidateJWTSVIDResponse::set_allocated_claims(::PROTOBUF_NAMESPACE_ID::Struct* claims) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claims_);
  }
  if (claims) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claims));
    if (message_arena != submessage_arena) {
      claims = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claims, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.claims_ = claims;
  // @@protoc_insertion_point(field_set_allocated:ValidateJWTSVIDResponse.claims)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_spiffe_2fworkload_2fworkload_2eproto
